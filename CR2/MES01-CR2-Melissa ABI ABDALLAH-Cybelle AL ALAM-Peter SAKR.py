# -*- coding: utf-8 -*-
"""Devoir 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XgsVVyDewLnLeUQtwt7a0-M4x8QU9gLw
"""

from google.colab import files
try:
    import dolfin ; import mshr ;
except ImportError as e:
    !apt-get install -y python-software-properties module-init-tools
    !add-apt-repository -y ppa:fenics-packages/fenics
    !apt-get update 
    !apt install -y fenics  
    import os
    # it needs restarting the kernel to work, to have python see the new python modules
    os.kill(os.getpid(), 9)

from dolfin import (dx, Constant, assemble_system, TestFunction, 
                    as_backend_type, assemble, PETScOptions, Function, plot, File, 
                    PETScMatrix, PETScVector, MPI)
from matplotlib.pyplot import subplots
import petsc4py
from slepc4py import SLEPc
from petsc4py import PETSc
import numpy as np
import dolfin
import ufl

class EigenSolver(object):
    def __init__(self, 
                 a_k, 
                 u,
                 a_m=None,                                   # optional, for eigpb of the type (K-lambda M)x=0
                 bcs=None,
                 restricted_dofs_is=None,
                 slepc_options={'eps_max_it':100},
                 option_prefix=None,
                 comm=MPI.comm_world, 
                 slepc_eigensolver = None
                ):
        self.comm = comm
        self.slepc_options = slepc_options
        if option_prefix:
            self.E.setOptionsPrefix(option_prefix)
        self.V = u.function_space()
        self.index_set_not_bc = None
        if type(bcs) == list:
            self.bcs = bcs
        elif type(bcs) == dolfin.fem.dirichletbc.DirichletBC:
            self.bcs = [bcs]
        else:
            self.bcs = None

        if type(a_k) == ufl.form.Form:
            # a form to be assembled
            self.K = as_backend_type(assemble(a_k)).mat()
        elif type(a_k) == petsc4py.PETSc.Mat:
            # an assembled petsc matrix
            self.K = a_k

        if a_m is not None and type(a_m) == ufl.form.Form:
            self.M = as_backend_type(assemble(a_m)).mat()
        elif a_m is not None and type(a_m) == petsc4py.PETSc.Mat:
            self.M = a_m

        # if bcs extract reduced matrices on dofs with no bcs
        if self.bcs:
            self.index_set_not_bc = self.get_interior_index_set(self.bcs, self.V)
        elif restricted_dofs_is:
            self.index_set_not_bc = restricted_dofs_is

        if self.index_set_not_bc is not None:
            try:
                self.K = self.K.createSubMatrix(self.index_set_not_bc, self.index_set_not_bc)
                if a_m is not None:
                   self.M = self.M.createSubMatrix(self.index_set_not_bc, self.index_set_not_bc)
            except:
                self.K = self.K.getSubMatrix(self.index_set_not_bc, self.index_set_not_bc)
                if a_m is not None:
                    self.M = self.M.getSubMatrix(self.index_set_not_bc, self.index_set_not_bc)
            self.projector = petsc4py.PETSc.Scatter()
            self.projector.create(
                vec_from=self.K.createVecRight(),
                is_from=None,
                vec_to=u.vector().vec(),
                is_to=self.index_set_not_bc
                )

        # set up the eigensolver
        if slepc_eigensolver:
            self.E = slepc_eigensolver
        else:
            self.E = self.eigensolver_setup()

        if a_m is not None:
            print(a_m)
            self.E.setOperators(self.K,self.M)       
        else:
            self.E.setOperators(self.K)
    
    def get_interior_index_set(self, boundary_conditions, function_space):
        """Returns the index set with free dofs"""
        # Find dofs affected by the boundary conditions
        bc_dofs = []    
        for bc in boundary_conditions:
            bc_dofs.extend(bc.get_boundary_values().keys()) 
        ownership_range = function_space.dofmap().ownership_range()
        interior_dofs = [x for x in range(ownership_range[0], ownership_range[1]) if x not in bc_dofs]    
        # Create petsc4py.PETSc.IS object with interior degrees of freedom
        index_set = petsc4py.PETSc.IS()
        index_set.createGeneral(interior_dofs)  
        return index_set

    def eigensolver_setup(self):
        E = SLEPc.EPS()
        E.create()        
        E.setType(SLEPc.EPS.Type.KRYLOVSCHUR)
        #E.setType(SLEPc.EPS.Type.LANCZOS)
        E.setProblemType(SLEPc.EPS.ProblemType.GHIEP)
        #E.setWhichEigenpairs(E.Which.LARGEST_MAGNITUDE)
        E.setWhichEigenpairs(E.Which.TARGET_MAGNITUDE)
        E.setTarget(0.) 
        st = E.getST()
        st.setType('sinvert')
        st.setShift(1.e-3)
        return E
        
    
    def solve(self, n_eig, verbose=True):
        E = self.E
        E.setDimensions(n_eig)
        self.set_options(self.slepc_options,verbose=verbose)
        E.setFromOptions()
        E.solve()
        # print info
        its = E.getIterationNumber()
        eps_type = E.getType()
        self.nev, ncv, mpd = E.getDimensions()
        tol, maxit = E.getTolerances()
        self.nconv = E.getConverged()
        if verbose == True:
            print("Solution method: {:s}, stopping condition: tol={:.4g}, maxit={:d}".format(eps_type,tol, maxit))
            print("Number of converged/requested eigenvalues with {:d} iterations  : {:d}/{:d}".format(its,self.nconv,self.nev))
        return self.nconv, its
        
    def set_options(self,slepc_options,verbose=True):
        if verbose == True:
            print("---- setting additional slepc options -----")
        for (opt, value) in slepc_options.items():
            if verbose == True:
                print("    ",opt,":",value)
            PETScOptions.set(opt,value) 
        self.E.setFromOptions()
        
    def get_eigenpair(self,i):
        u_r = Function(self.V)
        u_im = Function(self.V)
        v_r, v_i = self.K.createVecs()
        eig = self.E.getEigenpair(i, v_r, v_i)
        err = self.E.computeError(i)
        if self.index_set_not_bc:
            self.projector.scatter(vec_from=v_r, vec_to=u_r.vector().vec())
            self.projector.scatter(vec_from=v_i, vec_to=u_im.vector().vec())
            u_r.vector().vec().ghostUpdate()
            u_im.vector().vec().ghostUpdate()
        return eig, u_r, u_im, err
        
    def get_eigenvalues(self,n):
        eigenvalues = [] 
        for i in range(n):
            eig, u_r, u_im, err = self.get_eigenpair(i)
            eigenvalues.append([eig.real, err])
        return np.array(eigenvalues)
    
    def get_eigenpairs(self,n):
        eigenvalues = [] 
        eigenvectors_real = [] 
        eigenvectors_im = [] 
        for i in range(n):
            eig, u_r, u_im, err = self.get_eigenpair(i)
            eigenvalues.append(eig)
            eigenvectors_real.append(u_r)
            eigenvectors_im.append(u_im)
        return np.array(eigenvalues), [eigenvectors_real, eigenvectors_im]
    
    def save_eigenvectors(self,n,file_name="output/modes.pvd",save_imaginary=False):
        eigenvalues = [] 
        eigenvectors = [] 
        file = File(self.comm,file_name)
        for i in range(n):
            eig, u_r, u_im, err = self.get_eigenpair(i)
            u_r.rename("mode real","mode real")
            file.write(u_r,i)
            if save_imaginary:
                u_im.rename("mode imaginary","mode imaginary")
                file.write(u_im,i)
        print('saved eigenvectors in ', file_name)
        return file_name
    
    def plot_eigenpair(self,i):
        eig, u_r, u_im, err = self.get_eigenpair(i)
        p = plot(u_r,title="{:d} -- {:2.2f}".format(i,eig))
        return p 
    

if __name__ == "__main__":

    import dolfin
    import ufl
    import numpy as np
    import matplotlib.pyplot as plt
    dolfin.parameters["use_petsc_signal_handler"] = True
    dolfin.parameters["form_compiler"]["cpp_optimize"] = True
    dolfin.parameters["form_compiler"]["representation"] = "uflacs"

# Commented out IPython magic to ensure Python compatibility.
from dolfin import (dx, Constant, assemble_system, TestFunction, 
                    as_backend_type, assemble, PETScOptions, Function, plot, File, 
                    PETScMatrix, PETScVector, MPI)
from matplotlib.pyplot import subplots
import petsc4py
from slepc4py import SLEPc
from petsc4py import PETSc
import dolfin
import ufl
import os.path
# %matplotlib inline


plt.style.use("seaborn-notebook")

def pylon(Lx, Ly, Y, alpha):

  nu = 0.3
  nx = 40
  ny= 5
  mesh = dolfin.RectangleMesh(dolfin.Point(0,0), dolfin.Point(Lx,Ly),nx, ny)

  left = dolfin.CompiledSubDomain("near(x[0],0) && on_boundary")
  right = dolfin.CompiledSubDomain("on_boundary && near(x[0], Lx)", Lx=Lx)
  boundary_markers = dolfin.MeshFunction("size_t", mesh, dim= 1, value=0)
  left_index = 1
  right_index = 2
  left.mark(boundary_markers, left_index)
  right.mark(boundary_markers, right_index)

  ds = dolfin.ds(domain=mesh,subdomain_data=boundary_markers)
  dx = dolfin.dx(domain=mesh)
                
  V_element = dolfin.VectorElement("CG", mesh.ufl_cell(), degree=2,dim=2) 
  V = dolfin.FunctionSpace(mesh, V_element)
  u = dolfin.Function(V, name="u")

  I = ufl.Identity(2)    
  F = ufl.variable(I+ufl.grad(u))  
  C = F.T*F                   
  Ic = ufl.tr(C)
  J  = ufl.det(F)
  E = 1/2*(C-I)

  mu = dolfin.Constant(Y/(2*(1 + nu)))
  lmbda = dolfin.Constant(Y*nu/((1 + nu)*(1 - 2*nu)))
  lmbda = 2*lmbda*mu/(lmbda + 2*mu)

  psi = (mu/2)*(Ic - 2) - mu*ufl.ln(J) + (lmbda/2)*(ufl.ln(J))**2

  rho_g = 7.84 * Y * Ly**2 / 12 / Lx**3
  b0 = dolfin.Expression(("-t * rho_g * cos(alpha)", "t * rho_g * sin(alpha)"), t=0, alpha=alpha, rho_g=rho_g, degree=0)
  
  potential_energy = psi*dx - ufl.dot(b0, u)*dx 
  residual = ufl.derivative(potential_energy, u, dolfin.TestFunction(V))
  jacobian = ufl.derivative(residual, u, dolfin.TrialFunction(V))

  bcs = [dolfin.DirichletBC(V, (0., 0.), left)]

  problem = dolfin.NonlinearVariationalProblem(residual, u, bcs=bcs, J=jacobian)
  solver = dolfin.NonlinearVariationalSolver(problem)
      
  return(u,V,b0,ds,dx,Lx,Ly,jacobian,bcs,problem,solver,rho_g,potential_energy,mesh,Y,lmbda,mu,nu,left)

u,V,b0,ds,dx,Lx,Ly,jacobian,bcs,problem,solver,rho_g,potential_energy,mesh,Y,lmbda,mu,nu,left=pylon(Lx=1, Ly=0.1, Y=1000, alpha = 0.1)

neig = 6
eig_solver = EigenSolver(jacobian,u,bcs=bcs)
ncv, it = eig_solver.solve(neig,verbose=True)
eigenvalues, [eigenvectors_real, eigenvectors_im] = eig_solver.get_eigenpairs(ncv)
print("The smallest eigenvalues are \n", eigenvalues.real)
eig_solver.save_eigenvectors(ncv, 'results/eigenvectors-0.pvd')
plt.figure()
plt.plot(eigenvalues.real,'o')
plt.title("Eigenvalues")
figure = plt.figure(figsize = (10, 10))
for i in range(ncv):
    plt.subplot(int(ncv/2+1),2,i+1)
    dolfin.plot(eigenvectors_real[i],mode='displacement')
    plt.title("{:d} -- {:2.2e}".format(i,eigenvalues[i].real))

def stability_monitor(ddE, u, bcs, neig=2,verbose=True):
    eig_solver = EigenSolver(ddE, u, bcs=bcs)
    ncv, it = eig_solver.solve(neig,verbose=verbose) 
    eigenvalues, [eigenvectors_real, eigenvectors_im] = eig_solver.get_eigenpairs(ncv)
    min_eig = min(eigenvalues.real)
    return min_eig
    
stability_monitor(jacobian, u, bcs, neig=2)

u.assign(dolfin.Constant((0.,0.)))
loads = np.linspace(0.0, 2, 50)
forces = 0. * loads
displ = 0. * loads
min_eig = 0. * loads
vect_t = np.linspace(0.0,2,50)
u.rename("u","u")
file_u = File("results/nonlinear_compression.pvd");                    
for (i, t) in enumerate(loads):
    b0.t = t
    vect_t[i]=t
    solver.solve()
    min_eig[i]=stability_monitor(jacobian,u,bcs,neig=2,verbose=False)
    displ[i] = dolfin.assemble(u[1]*ds(2))/Lx 
    file_u << (u,t)
plt.figure(0)
plot(u, mode = "displacement")
plt.figure(1)
plt.plot(loads,displ,"*")
plt.xlabel("load")
plt.ylabel("End displacement")
plt.figure(2)
plt.plot(loads,min_eig,"*")
plt.grid()
plt.xlabel("load")
plt.ylabel("smallest eigenvalue")

plt.figure(3)
plt.plot(vect_t,displ/Lx,"*")
plt.plot(vect_t,-displ/Lx, "*")
plt.grid()
plt.xlabel('t')
plt.ylabel('U_L/Lx')

if min_eig[i] > 0 :
  plt.plot(vect_t,displ/Lx,'g')
  plt.plot(vect_t,-displ/Lx, 'g')
elif min_eig[i] < 0 :
  plt.plot(vect_t,displ/Lx,'r')
  plt.plot(vect_t,-displ/Lx, 'r')